{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Note</p> <p>Early in development. Still work in progress!</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Welcome to the official knowledge base of open robotic metaverse. Here, we provide comprehensive resources, guidelines, and insights to acquaint you with the revolutionary metaverse of simulated autonomous robots.</p>"},{"location":"#what-we-offer","title":"What We Offer","text":"<ul> <li>Open-Source Resources: Explore our extensive library of codes, algorithms, and tools available for researchers, developers, and enthusiasts alike.</li> <li>Interactive Challenges: Get hands-on experience with simulated robotics, from basic principles to advanced techniques.</li> <li>Realistic Simulations: Dive deep into our rich and detailed simulations, where robots face real-world challenges, enabling precise analysis and refinement.</li> <li>Community Support: Connect with a local community of robotic enthusiasts, share ideas, seek guidance, and collaborate on groundbreaking projects.</li> </ul>"},{"location":"#why-simulation","title":"Why Simulation?","text":"<p>Simulation provides a risk-free and cost-effective environment for testing and refining robotic algorithms. In the virtual world, robots can learn, adapt, and evolve, ensuring their readiness for real-world applications. With our state-of-the-art simulation tools, we aim to accelerate the path to a future where autonomous robots seamlessly integrate into our daily lives.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Ready to embark on this exciting journey? Browse our knowledge base to discover tutorials, research papers, case studies, and much more. Whether you're a seasoned expert or just starting out, there's something here for everyone.</p> <p>Begin your journey Learn more about us</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#who-are-we","title":"Who are we?","text":"<p>We are open robotic metaverse or in short orom, a student initiative currently in the founding process. Our founders are students from RWTH Aachen University and FH Aachen and highly motivated to strengthen the robotic community in and outside of Aachen, Germany.</p> <p></p>"},{"location":"about/#vision","title":"Vision","text":"<p>We aim to bring the robotics community together, both locally and virtually, to encourage collaboration and innovation. Our efforts indirectly support the acceleration of robotics application development while making the technology more accessible. We help individuals gain skills and knowledge in this field and connect them with companies looking for solution implementers, all while building a connected and passionate community.</p>"},{"location":"about/#mission","title":"Mission","text":"<p>We are creating a platform that helps everyone embrace their experiences with robotics from various angles.</p> <p>Key Features</p> <ul> <li>Community: We are an active community open to professionals, beginners, and enthusiasts alike. We strongly encourage the exchange of knowledge and Ideas.</li> <li>Project Platform: Our platform enables users to explore different robotics projects, find inspiration, share their projects, or discover collaboration opportunities. In our vision, we aim to create an open Metaverse where solutions are engineered and showcased. This allows everyone to explore various running solutions, draw inspiration or offer support.</li> <li>Facilitation Tools: We provide ready-to-use building blocks that make starting with robotics and simulation quicker and more intuitive.</li> <li>Educational Materials and Mentorship: We offer an easy-to-follow guide for learning robotics. We encourage a culture of support where the more experienced members assist those newer in the field and we believe that we all can always learn from each other.</li> <li>Bridging Theory and Practice: We strive to bridge the gap between the theoretical knowledge found in academic institutions and the practical needs of the industry.</li> <li>Open-Source Involvement: We contribute to the open-source community and welcome everyone to join our vision.*</li> </ul> <p>Additional Services</p> <p>In parallel to our main activities, we also offer the following:</p> <ul> <li>Sim2Real: We aim to close the gap between simulation and reality. With our partners, we provide access to hardware for testing applications developed in the simulation environment.</li> <li>Incubation Support: We connect motivated working groups with incubation programs, helping them transform their ideas into startups and thereby accelerate innovation in the robotics field.</li> </ul> <p>Our Approach</p> <ul> <li>Development: We are committed to developing valuable building blocks for simulation environments and robotic applications. Furthermore, we encourage the use of open-source libraries to prevent redundant work.</li> <li>Education and Learning: We are dedicated contributors to our learning platform, emphasizing both content and practical insights.</li> <li>Event Organization and Participation: We host relevant events, including presentations from researchers or startups in the field, as well as hackathons combined with social events to foster community spirit. Additionally, we aim to actively participate in external events such as ROSCon or Automatica.</li> <li>Collaboration: We maintain active communication with institutes and researchers in the robotics field. This ensures we remain updated with the latest technologies while also collaborating with the industry to address relevant use cases.</li> </ul> <p>We create Value</p> <ul> <li>For society<ul> <li>We help the democratization of robotic Technology by making it accessible to everyone.</li> <li>We support the education system by providing up-to-date knowledge combined with hands-on experience.</li> <li>Bridging Academia &amp; Industry: support collaborations between students, industries, and research institutes.</li> </ul> </li> <li>For students<ul> <li>Familiarize yourself with the development process of robotic applications, leveraging the capabilities of Simulation and gain hands-on experience.</li> <li>Become part of a growing robotics community; discover possibilities and get inspiration.</li> <li>Connect with industry and research institutes for job opportunities and thesis collaborations.</li> </ul> </li> <li>For Research Institutes and companies<ul> <li>Gain fresh perspectives on your challenges.</li> <li>Employer branding. Connect with skilled students.</li> </ul> </li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>First and foremost, thank you for considering contributing to our knowledge base! Every contribution, whether it's a typo fix or a new article, helps us improve and grow. This document provides guidelines and steps for contributing.</p>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>The most recent version of our code of conducs can be viewed here. </p> <p>By participating, you are expected to uphold this code. Please report unacceptable behavior to openroboticmetaverse@gmail.org.</p>"},{"location":"contribute/#how-can-i-contribute","title":"How Can I Contribute?","text":""},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<ul> <li>Check if the issue is already reported.</li> <li>Provide a clear and descriptive title.</li> <li>Describe the expected behavior and what you actually experienced.</li> <li>Include screenshots and animated GIFs if possible.</li> </ul>"},{"location":"contribute/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<ul> <li>Provide a clear and descriptive title.</li> <li>Explain why this enhancement would be useful to most users.</li> <li>List some other platforms where this enhancement exists, if applicable.</li> </ul>"},{"location":"contribute/#submission-guidelines","title":"Submission Guidelines","text":""},{"location":"contribute/#writing-content","title":"Writing Content","text":"<ul> <li>Use clear, concise, and simple language.</li> <li>Ensure content is up-to-date and accurate.</li> <li>Use headers and subheaders to organize content.</li> <li>Avoid jargon or overly technical language.</li> </ul>"},{"location":"contribute/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Fork the Repository: Start by forking our repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.</li> <li>Make Your Changes: Edit the files and make your changes.</li> <li>Pull Request: Submit a pull request from your fork to the main repository.</li> </ol> <p>Your pull request will be reviewed by the maintainers, who might ask for some changes or clarification. Once approved, your contribution will be merged. Congratulations and thank you!</p>"},{"location":"get-started/","title":"MVP Documentation","text":""},{"location":"get-started/#1-project-overview","title":"1. Project Overview","text":"<p>This iteration of the MVP is a 3D scene management application that allows users to create, manipulate, and visualize 3D scenes with objects and robots. The application is built using:</p> <ul> <li>React TypeScript for the frontend</li> <li>MobX for state management</li> <li>Three.js (via react-three-fiber) for 3D rendering</li> <li>Django for Backend</li> <li>PostgresSQL Database</li> </ul>"},{"location":"get-started/#11-backend-data-model","title":"1.1 Backend Data Model","text":"<p>This diagram illustrates the data model and relationships for the MVP's 3D scene management application. It's divided into two main sections:</p> <ol> <li>Scene Management (pink section):</li> </ol> <p>Shows the structure of Scene, AbstractObject, Object, and Robot entities. Scene has properties like ID, name, user_id, and timestamps. AbstractObject is a base class with common properties like position, orientation, and scale. Object and Robot inherit from AbstractObject, with Object having a color property and Robot having joint_angles.</p> <ol> <li>Object Library (blue section):</li> </ol> <p>Displays the structure of AbstractReference, ReferenceObject, and ReferenceRobot. AbstractReference contains common properties like ID, name, file, and description. ReferenceRobot and ReferenceObject inherit from AbstractReference, with ReferenceRobot having a num_joints property.</p> <p></p>"},{"location":"get-started/#2-api-structure","title":"2. API Structure","text":"<p>The API is structured into two main sections:</p>"},{"location":"get-started/#21-object-library","title":"2.1 Object Library","text":"<ul> <li>Reference Robots (<code>/library/ref-robots/</code>)</li> <li>Reference Objects (<code>/library/ref-objects/</code>)</li> </ul>"},{"location":"get-started/#22-scene-manager","title":"2.2 Scene Manager","text":"<ul> <li>Scenes (<code>/scene-manager/scenes/</code>)</li> <li>Robots (<code>/scene-manager/robots/</code>)</li> <li>Objects (<code>/scene-manager/objects/</code>)</li> </ul> <p>Each endpoint supports standard CRUD operations (GET, POST, PUT, PATCH, DELETE).</p>"},{"location":"get-started/#3-data-models","title":"3. Data Models","text":"<p>The project uses several key interfaces to represent data:</p>"},{"location":"get-started/#31-base-interfaces","title":"3.1 Base Interfaces","text":"<ul> <li><code>IAbstractObject</code>: Base interface for objects and robots</li> <li><code>IAbstractReference</code>: Base interface for object and robot references</li> </ul>"},{"location":"get-started/#32-scene-management-interfaces","title":"3.2 Scene Management Interfaces","text":"<ul> <li><code>IScene</code>: Represents a 3D scene</li> <li><code>IObject</code>: Represents an object in a scene (extends <code>IAbstractObject</code>)</li> <li><code>IRobot</code>: Represents a robot in a scene (extends <code>IAbstractObject</code>)</li> </ul>"},{"location":"get-started/#33-object-library-interfaces","title":"3.3 Object Library Interfaces","text":"<ul> <li><code>IReferenceRobot</code>: Represents a reference robot (extends <code>IAbstractReference</code>)</li> <li><code>IReferenceObject</code>: Represents a reference object (extends <code>IAbstractReference</code>)</li> </ul>"},{"location":"get-started/#4-state-management","title":"4. State Management","text":"<p>The project uses MobX for state management. This section provides a detailed look at each store, its purpose, key observables, and important actions.</p>"},{"location":"get-started/#41-basestore","title":"4.1 BaseStore","text":"<p><code>BaseStore</code> is a generic abstract class that provides common functionality for other stores.</p> <p>Key features:</p> <ul> <li><code>@observable items</code>: An array to store the main data of the store.</li> <li><code>@observable state</code>: Represents the current state of the store (idle, loading, success, or error).</li> <li><code>fetchItems</code>: A protected method to fetch items from an API.</li> <li><code>updateItem</code>: A protected method to update an item in the store.</li> <li><code>deleteItem</code>: A protected method to delete an item from the store.</li> <li><code>getItemById</code>: A method to retrieve an item by its ID.</li> </ul>"},{"location":"get-started/#42-librarystore","title":"4.2 LibraryStore","text":"<p><code>LibraryStore</code> manages the state of reference objects and robots.</p> <p>Key observables:</p> <ul> <li><code>@observable referenceObjects</code>: An array of <code>IReferenceObject</code>.</li> <li><code>@observable referenceRobots</code>: An array of <code>IReferenceRobot</code>.</li> </ul> <p>Important actions:</p> <ul> <li><code>@action fetchLibraryData</code>: Fetches both reference objects and robots from the API.</li> <li><code>getReferenceObjectById</code>: Retrieves a reference object by its ID.</li> <li><code>getReferenceRobotById</code>: Retrieves a reference robot by its ID.</li> </ul>"},{"location":"get-started/#43-scenestore","title":"4.3 SceneStore","text":"<p><code>SceneStore</code> manages the state of scenes.</p> <p>Key observables:</p> <ul> <li><code>@observable activeSceneId</code>: The ID of the currently active scene.</li> <li><code>@observable newSceneName</code>: The name for a new scene being created.</li> </ul> <p>Important actions:</p> <ul> <li><code>@action setActiveScene</code>: Sets the active scene by ID.</li> <li><code>@action fetchScenes</code>: Fetches all scenes from the API.</li> <li><code>@action createScene</code>: Creates a new scene.</li> <li><code>@action updateScene</code>: Updates an existing scene.</li> <li><code>@action deleteScene</code>: Deletes a scene.</li> </ul> <p>Computed values:</p> <ul> <li><code>@computed get activeScene</code>: Returns the currently active scene object.</li> </ul>"},{"location":"get-started/#44-objectstore","title":"4.4 ObjectStore","text":"<p><code>ObjectStore</code> manages the state of objects in scenes.</p> <p>Key observables:</p> <ul> <li>Inherits <code>@observable items</code> from BaseStore, which stores <code>IObject</code> instances.</li> </ul> <p>Important actions:</p> <ul> <li><code>@action fetchObjects</code>: Fetches all objects from the API.</li> <li><code>@action createObject</code>: Creates a new object.</li> <li><code>@action updateObject</code>: Updates an existing object.</li> <li><code>@action deleteObject</code>: Deletes an object.</li> <li><code>@action getObjectsForScene</code>: Retrieves all objects for a specific scene.</li> </ul>"},{"location":"get-started/#45-robotstore","title":"4.5 RobotStore","text":"<p><code>RobotStore</code> manages the state of robots in scenes.</p> <p>Key observables:</p> <ul> <li>Inherits <code>@observable items</code> from BaseStore, which stores <code>IRobot</code> instances.</li> </ul> <p>Important actions:</p> <ul> <li><code>@action fetchRobots</code>: Fetches all robots from the API.</li> <li><code>@action createRobot</code>: Creates a new robot.</li> <li><code>@action updateRobot</code>: Updates an existing robot.</li> <li><code>@action deleteRobot</code>: Deletes a robot.</li> <li><code>@action getRobotsForScene</code>: Retrieves all robots for a specific scene.</li> </ul>"},{"location":"get-started/#46-errorstore","title":"4.6 ErrorStore","text":"<p><code>ErrorStore</code> manages application-wide errors.</p> <p>Key observables:</p> <ul> <li><code>@observable errors</code>: An array of Error objects.</li> </ul> <p>Important actions:</p> <ul> <li><code>@action addError</code>: Adds a new error to the store.</li> <li><code>@action clearErrors</code>: Clears all errors from the store.</li> </ul>"},{"location":"get-started/#47-leveraging-mobx-in-the-3d-application","title":"4.7 Leveraging MobX in the 3D Application","text":"<p>MobX provides powerful tools for managing state in your 3D application. Here's how you can leverage MobX concepts within the current state management structure:</p>"},{"location":"get-started/#471-observables","title":"4.7.1 Observables","text":"<p>Observables are at the core of MobX. In our stores, we use observables to track various aspects of the application state:</p> <ul> <li>In <code>SceneStore</code>: <code>@observable activeSceneId</code> tracks the current scene.</li> <li>In <code>ObjectStore</code> and <code>RobotStore</code>: <code>@observable items</code> arrays store the objects and robots.</li> <li>In <code>LibraryStore</code>: <code>@observable referenceObjects</code> and <code>@observable referenceRobots</code> store available models.</li> </ul> <p>Example usage:</p> <pre><code>@observable activeSceneId: string | null = null;\n</code></pre>"},{"location":"get-started/#472-computed-values","title":"4.7.2 Computed Values","text":"<p>Computed values derive information from observables. They're used throughout our stores to calculate values based on the current state:</p> <ul> <li>In <code>SceneStore</code>: <code>@computed get activeScene()</code> returns the currently active scene object.</li> </ul> <p>Example usage:</p> <pre><code>@computed get activeScene(): IScene | undefined {\n  return this.items.find((scene) =&gt; scene.id === this.activeSceneId);\n}\n</code></pre>"},{"location":"get-started/#473-actions","title":"4.7.3 Actions","text":"<p>Actions are methods that modify the state. All state modifications in our stores are wrapped in <code>@action</code> decorators:</p> <ul> <li>In <code>SceneStore</code>: <code>@action setActiveScene()</code>, <code>@action createScene()</code>, etc.</li> <li>In <code>ObjectStore</code> and <code>RobotStore</code>: <code>@action createObject()</code>, <code>@action updateRobot()</code>, etc.</li> </ul> <p>Example usage:</p> <pre><code>@action\nsetActiveScene(sceneId: string | null) {\n  this.activeSceneId = sceneId;\n}\n</code></pre>"},{"location":"get-started/#474-reactions","title":"4.7.4 Reactions","text":"<p>While not explicitly defined in our stores, reactions are used in components to respond to state changes. For example, in the <code>MainScene</code> component, we use <code>useEffect</code> to show toast messages when the scene store state changes.</p> <p>Example usage:</p> <pre><code>useEffect(() =&gt; {\n  if (sceneStore.state.status === \"error\") {\n    toast({\n      variant: \"destructive\",\n      title: \"Error\",\n      description: sceneStore.state.error,\n    });\n  }\n}, [sceneStore.state.status]);\n</code></pre>"},{"location":"get-started/#475-applying-mobx-to-3d-rendering","title":"4.7.5 Applying MobX to 3D Rendering","text":"<p>To leverage MobX in the 3D aspects of your application:</p> <ol> <li>Scene Management:</li> </ol> <p>Use <code>SceneStore</code> to manage the overall scene state.</p> <p>React to changes in <code>activeSceneId</code> to load or unload 3D content.</p> <ol> <li> <p>Object Manipulation:</p> </li> <li> <p>Use <code>ObjectStore</code> and <code>RobotStore</code> to manage individual 3D entities.      Create actions for transforming objects (move, rotate, scale).</p> </li> <li> <p>Real-time Updates:    Make your 3D components observers of relevant stores.    This ensures they re-render when the observed state changes.</p> </li> <li>Performance Optimization:    Use computed values for expensive calculations in the 3D scene.    This helps avoid unnecessary recalculations.</li> <li>User Interactions:    Tie user interactions (like clicking on a 3D object) to MobX actions.    This keeps all state changes centralized and trackable.</li> </ol> <p>Example of a 3D component using MobX:</p> <pre><code>const SceneObject = observer(({ objectId }) =&gt; {\n  const object = objectStore.getItemById(objectId);\n\n  useFrame(() =&gt; {\n    // Update object's 3D representation based on its state\n    // This will automatically re-run when the object's state changes\n  });\n\n  return (\n    &lt;mesh position={object.position} rotation={object.rotation}&gt;\n      {/* Object geometry and material */}\n    &lt;/mesh&gt;\n  );\n});\n</code></pre>"},{"location":"get-started/#48-store-interactions","title":"4.8 Store Interactions","text":"<p>The stores interact with each other and the components in several ways:</p> <ol> <li>SceneStore and ObjectStore/RobotStore: When a scene is selected in SceneStore, ObjectStore and RobotStore use the active scene ID to filter and display relevant objects and robots.</li> <li>LibraryStore and ObjectStore/RobotStore: When creating new objects or robots, the reference data from LibraryStore is used to populate the initial properties.</li> <li>ErrorStore and other stores: All other stores use ErrorStore to log errors that occur during API calls or other operations.</li> <li>Stores and Components: React components use the <code>observer</code> HOC from MobX to automatically re-render when relevant observables change. They also call store actions to update the application state.</li> </ol>"},{"location":"get-started/#49-mobx-best-practices-used","title":"4.9 MobX Best Practices Used","text":"<ol> <li>Derivations: Computed values like <code>activeScene</code> in SceneStore are used for derived state.</li> <li>Actions: All state modifications are wrapped in <code>@action</code> decorators to ensure they're tracked by MobX.</li> <li>Reactions: Components use <code>useEffect</code> with MobX observables to trigger side effects when state changes.</li> <li>Batching Updates: <code>runInAction</code> is used in asynchronous actions to batch updates and reduce re-renders.</li> </ol>"},{"location":"get-started/#5-ui-components","title":"5. UI Components","text":""},{"location":"get-started/#51-sceneselector","title":"5.1 SceneSelector","text":"<ul> <li>Allows users to select and manage scenes</li> <li>Displays a grid of available scenes</li> <li>Provides functionality to create new scenes</li> </ul>"},{"location":"get-started/#52-modelbrowser","title":"5.2 ModelBrowser","text":"<ul> <li>Displays a list of available models (primitive shapes, custom objects, and robots)</li> <li>Allows users to search and filter models</li> <li>Provides functionality to add models to the active scene</li> </ul>"},{"location":"get-started/#53-mainscene","title":"5.3 MainScene","text":"<ul> <li>Main component for rendering the 3D scene</li> <li>Handles different states (loading, error, no active scene)</li> <li>Renders the Canvas component when a scene is active</li> </ul>"},{"location":"get-started/#6-3d-rendering","title":"6. 3D Rendering","text":"<p>The project uses react-three-fiber for 3D rendering. Key components include:</p>"},{"location":"get-started/#61-scenecontent","title":"6.1 SceneContent","text":"<ul> <li>Renders the content of the active scene</li> <li>Manages the creation, updating, and removal of 3D objects</li> </ul>"},{"location":"get-started/#62-sceneobject-and-scenerobot","title":"6.2 SceneObject and SceneRobot","text":"<ul> <li>Render individual objects and robots in the scene</li> </ul>"},{"location":"get-started/#63-customtransformcontrols","title":"6.3 CustomTransformControls","text":"<ul> <li>Provides controls for transforming (moving, rotating, scaling) objects in the scene</li> </ul>"},{"location":"get-started/#64-sceneenvironment","title":"6.4 SceneEnvironment","text":"<ul> <li>Sets up the 3D environment (lights, grid, controls)</li> </ul>"},{"location":"get-started/#65-renderobject-and-renderrobot","title":"6.5 renderObject and renderRobot","text":"<ul> <li>Helper functions for rendering objects and robots</li> </ul>"},{"location":"get-started/#7-api-integration","title":"7. API Integration","text":"<p>The <code>api.ts</code> file provides functions for interacting with the backend API:</p>"},{"location":"get-started/#71-scenemanagerapi","title":"7.1 sceneManagerApi","text":"<ul> <li>Functions for managing scenes, objects, and robots</li> </ul>"},{"location":"get-started/#72-objectlibraryapi","title":"7.2 objectLibraryApi","text":"<ul> <li>Functions for managing reference objects and robots</li> </ul> <p>These functions handle API requests, responses, and error handling, integrating with the toast notification system for user feedback.</p>"}]}